% function dotsShow(rseed, duration, fp)function dotsShow_SS(rseed, duration, fp)% 2017-09. Modified by SS to allow varying of coherence during trials.% Coherence as defined in dots_struct is now a vector and can be changed% per frame. % Args:%   rseed   random seed, can be a single value or an array. when an array%           the state of the random number generator is set to prod(rseed).%           Rex usually send a vector with two number [seed_base seed_var]%   duration    an array of durations, set the duration to -1 when a dots%               patch should not be shown %   global screen_struct dots_struct MAX_DOTS_PER_FRAME udpmsg_struct%% function parameters show_huk = false;% if dots_struct(1).coherence_std>0%     %reset the random number generator%     if nargin>=1 && ~isempty(rseed)%         rand('twister', prod(rseed));%     else%         rand('state', sum(100*clock));%     end%     show_huk = true;%     stim_id  = ceil(huk_struct.num_stims*rand());%     %     Igamma3d = huk_struct.stimuli{stim_id};%     % end%REPEAT reset the random number generator, to %use the same offline dot re-generation codeif nargin>=1 && ~isempty(rseed)    rand('twister', prod(rseed));else	rand('state', sum(100*clock));end%set maximum dot duration to 10 sec if not specifiedif nargin<2 || isempty(duration)    duration = 10;else    duration = duration(:)';    %make sure it is a row vector end%if a valid file pointer is not specified print the udpmsg commands on%the standard output if nargin<3 || isempty(fp)    fp = 1;end% save the command id, it will be used to send "executed" after the% first frame of dots is shown id_ff = udpmsg_struct.recv_id;  % set the break_loop id to empty for now. will be filled when Rex sends% the break loop commandid_bl = '';  %% Initialize dots parameters  % set variables that will be needed for the calculation of dots position% we will generate dots in a bigger aperture than necessary and% then apply a mask of appropriate sizeaperture = cat(1, dots_struct.aperture); aperture(3:4) = aperture(3:4) * 2;direction = cat(1, dots_struct.direction);density = cat(1, dots_struct.density);% calculate the number of dots for a 'rectangular' aperture, we% will apply an oval mask at each framendots = min(MAX_DOTS_PER_FRAME, ...            round(density .* (aperture(:,3).*aperture(:,4)) / screen_struct.mon_refresh));num_patch = length(dots_struct);loopi = ones(num_patch, 1);dxdy = cell(num_patch, 1);dot_angle = pi*direction/180;d_ppd = cell(num_patch, 1);dot_pos = cell(num_patch, 1);AP = repmat(struct([]), num_patch, 1);if length(duration)==1    duration = repmat(duration, [num_patch,1]);endfor df = num_patch : -1 : 1    %loop in reverse order to avoid memory reallocation        %define the ellipse apertures in the screen coordinates    AP(df).type = 'ellipse';    AP(df).spec.center = deg2screen(aperture(df,1:2), screen_struct, 'v');    AP(df).spec.radius = aperture(df,3:4)/2 * screen_struct.pix_per_deg;            %find the xy displacement of coherent dots for each dot field    dxdy{df} = repmat(dots_struct(df).speed*dots_struct(df).interval/screen_struct.mon_refresh*...                      [cos(dot_angle(df)) -sin(dot_angle(df))], ndots(df), 1) * screen_struct.pix_per_deg;        d_ppd{df} = repmat(AP(df).spec.radius, ndots(df), 1);        % Define the initial set of dot positions equal to the interval    dot_pos{df} = (rand(ndots(df),2,dots_struct(df).interval)-0.5)*2;    for j = 1 : dots_struct(df).interval        dot_pos{df}(:,:,j) = dot_pos{df}(:,:,j) .* d_ppd{df};    end        %allocate memory for saving the dot position     dots_struct(df).dot_pos = nan(ndots(df), 2, ceil(screen_struct.mon_refresh*(duration(df)+1)));        %keep track of the number of frames shown    dots_struct(df).shown_frames = 0;    end    %make a copy of AP struct with aperture center set to zero (used    %for defining the mask) AP_ = AP;for df = 1 : num_patch    AP_(df).spec.center = [0 0];     % cut down to appropriate size since we generated twice     % as many as needed    AP_(df).spec.radius =  AP_(df).spec.radius/2;end%% draw dots on the screen break_loop = 0;start_t = GetSecs;  %save the start time. it will be updated after the first frame is showncur_f = 0; % Current frame while 1    %endless loop        cur_t = GetSecs - start_t;    cur_f = cur_f + 1; % Keep track of frames            %which dots patches are still running     show_patch = find(cur_t < duration);        %check if all dot fields have finished showing. note that the code        %allows different dot fields to continue for different periods.     if isempty(show_patch)        break_loop = 1;    end            % MANAGE THE UDP MESSAGING         % REX sets break_loop to 1 to stop the presentation        % all other messages can be handled too, including changing the        % dots parameters or target appearance.    if udpmsg('check')        [message, id] = udpmsg('receive');        if ~isempty(message)                %log the message in fp             fprintf(fp,'%s\n', message);                        %fprintf('%s, %s\n', message, id);                            %evaluate the message            eval(message);                %confirm the execution of the message unless break_loop is                %set to one            if break_loop == 0                udpmsg('send', 'EXECUTED', id);            else                id_bl = id;            end        end    end            % break the loop if necesary     if break_loop        break;    end            % update the dot position and draw them on the screen    for df = show_patch,                %show huk noise if required        if (show_huk)                        Igamma = Igamma3d(:,:,dots_struct(df).shown_frames + 1);                        texturePointer(dots_struct(df).shown_frames + 1) = Screen('MakeTexture', screen_struct.cur_window, Igamma);            rotation = -1 * direction(df);%-1 to make anti-clockwise                        filtMode  = 0;            hukApRect = AP(df).spec.center([1 2 1 2]) + AP_(df).spec.radius([1 2 1 2]) .* [-1 -1 1 1];            Screen('DrawTexture', screen_struct.cur_window, ...                  texturePointer(dots_struct(df).shown_frames + 1),[],hukApRect, rotation,filtMode);        end                    %find the index of coherently moving dots in this frame        L = rand(ndots(df),1) < dots_struct(df).coherence(cur_f);            %move the coherent dots        dot_pos{df}(L,:,loopi(df)) = dot_pos{df}(L,:,loopi(df)) + dxdy{df}(L,:);            %replace the other dots        dot_pos{df}(~L,:,loopi(df)) = (rand(sum(~L),2)-0.5)*2 .* d_ppd{df}(~L,:);            %wrap around        L = dot_pos{df}(:,1,loopi(df)) > d_ppd{df}(:,1);        dot_pos{df}(L,1,loopi(df)) = dot_pos{df}(L,1,loopi(df)) - 2*d_ppd{df}(L,1);        L = dot_pos{df}(:,1,loopi(df)) < -d_ppd{df}(:,1);        dot_pos{df}(L,1,loopi(df)) = 2*d_ppd{df}(L,1) - dot_pos{df}(L,1,loopi(df));        L = dot_pos{df}(:,2,loopi(df)) > d_ppd{df}(:,2);        dot_pos{df}(L,2,loopi(df)) = dot_pos{df}(L,2,loopi(df)) - 2*d_ppd{df}(L,2);        L = dot_pos{df}(:,2,loopi(df)) < -d_ppd{df}(:,2);        dot_pos{df}(L,2,loopi(df)) = 2*d_ppd{df}(L,2) - dot_pos{df}(L,2,loopi(df));                %find dots that should be shown in the aperture, note that dot_pos            %is calculated relative to the center of aperture. so use aperture_            %made for this purpose        L = isInsideRegion(dot_pos{df}(:,:,loopi(df)), AP_(df));            %round the dot_pos but save it in another place because we'd like            %dot_pos to keep track of decimals            %also rotate the matrix because Screen wants positions in row format         pos = round(dot_pos{df}(L,:,loopi(df)))';            %put dots on the screen        if any(isnan(prod(pos,1))==0)            Screen('DrawDots', screen_struct.cur_window, pos, dots_struct(df).dot_size, dots_struct(df).dot_color', AP(df).spec.center);        end            %increment the frame counter             dots_struct(df).shown_frames = dots_struct(df).shown_frames + 1;        %save the location of the shown dots        dots_struct(df).dot_pos(L,:,dots_struct(df).shown_frames) = pos';        %update the loop counter        loopi(df) = loopi(df) + 1;        if loopi(df) > dots_struct(df).interval,            loopi(df) = 1;        end;            end;            %redraw the fixation point and targets because the flip command    %erases them on each frame!    if dots_struct(show_patch(1)).shown_frames == 1,        targDraw([], [], 0, 1); % flip PhotoDetectorFlash    else,        targDraw([], [], 0, 0); % don't flip it on every frame    end        %flip the screen     flipScreen;           %set start_t after the first frame. this is the true beginning of    %dots. also send a message at the end of the first frame. for this    %message use the id of the command that called showDots.    if dots_struct(show_patch(1)).shown_frames == 1,        start_t = GetSecs;        udpmsg('send', 'EXECUTED', id_ff);    end; end;%clear the dot field. targDraw([], [], 0, 1); % flip PhotoDetectorFlash%flip the screen flipScreen;       %send "executed". use the id of the command that set break_loop to 1if ~isempty(id_bl)        udpmsg('send', 'EXECUTED', id_bl);    %fprintf('dots duration: %f sec\n', GetSecs-start_t);    %fprintf('dot frames = %f\n', dots_struct(df).shown_frames);end    %save the shown dot locations    %known bug: this line assumes only one patch of dots. it    %needs to be replaced by a for loop to accommodate multiple    %patchesfor df = 1 : length(dots_struct)    dots_struct(df).dot_pos = dots_struct(df).dot_pos(:,:,1:dots_struct(df).shown_frames);end%dots_struct(1).dot_pos% close huk texturesif (show_huk)    Screen('Close', texturePointer);end