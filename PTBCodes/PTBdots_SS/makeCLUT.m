function makeCLUT% SET UP COLOR LOOKUP TABLE% 		computes screen pixel conversion constants%% History:% 5/28/01 jig created from initScreendeclareGlobals;			% dot global variable declaration% set up the CLUT ("color look-up table")% First set up indices into CLUT ("_INDEX")% CLUT is 8 bits... reserve particular bits for particular display objects% in order to be able to xor% Remember that we can use "0" for only one set% Bit 1 is the aperture% 	we'll be clever and use this as the aperture foreground% 	so we don't have to explicitly define xor for itAPFG_INDEX			= 0;APBG_INDEX			= 1;% Bits 2 - 5 are for Targets (and FPs)	% these are pre-defined colorsT_RED_INDEX  		= bitshift(1, 1);T_GREEN_INDEX 		= bitshift(2, 1);T_BLUE_INDEX 		= bitshift(3, 1);T_YELLOW_INDEX 		= bitshift(4, 1);T_WHITE_INDEX 		= bitshift(5, 1);T_GRAY_INDEX 		= bitshift(6, 1);	% these are for user-modifiable colorsT1_INDEX			= bitshift(7, 1);T2_INDEX			= bitshift(8, 1);T3_INDEX			= bitshift(9, 1);T4_INDEX			= bitshift(10, 1);T5_INDEX			= bitshift(11, 1);T6_INDEX			= bitshift(12, 1);T7_INDEX			= bitshift(13, 1);T8_INDEX			= bitshift(14, 1);T9_INDEX			= bitshift(15, 1);% Bits 6 - 8 are for DOTSDOT_RED_INDEX 		= bitshift(1, 5);DOT_GREEN_INDEX 	= bitshift(2, 5);DOT_BLUE_INDEX 		= bitshift(3, 5);DOT_YELLOW_INDEX	= bitshift(4, 5);DOT_WHITE_INDEX 	= bitshift(5, 5);DOT_GRAY1_INDEX 	= bitshift(6, 5);DOT_GRAY2_INDEX 	= bitshift(7, 5);% Set the CLUT valuesDOTS_CLUT = zeros(256, 3);% Aperture and background are blackDOTS_CLUT(APFG_INDEX 		+ 1, :) = CBLACK;DOTS_CLUT(APBG_INDEX 		+ 1, :) = CBLACK;% First 6 targets are pre-definedDOTS_CLUT(T_RED_INDEX 		+ 1, :) = CRED;DOTS_CLUT(T_GREEN_INDEX 	+ 1, :) = CGREEN;DOTS_CLUT(T_BLUE_INDEX 		+ 1, :) = CBLUE;DOTS_CLUT(T_YELLOW_INDEX 	+ 1, :) = CYELLOW;DOTS_CLUT(T_WHITE_INDEX 	+ 1, :) = CWHITE;DOTS_CLUT(T_GRAY_INDEX 		+ 1, :) = CGRAY;% Dot colors are pre-definedDOTS_CLUT(DOT_RED_INDEX 	+ 1, :)	= CRED;DOTS_CLUT(DOT_GREEN_INDEX 	+ 1, :)	= CGREEN;DOTS_CLUT(DOT_BLUE_INDEX 	+ 1, :)	= CBLUE;DOTS_CLUT(DOT_YELLOW_INDEX 	+ 1, :)	= CYELLOW;DOTS_CLUT(DOT_WHITE_INDEX 	+ 1, :)	= CWHITE;DOTS_CLUT(DOT_GRAY1_INDEX 	+ 1, :)	= CGRAY;DOTS_CLUT(DOT_GRAY2_INDEX 	+ 1, :)	= CGRAY2;% Set the XOR values between dots and other objectssetDotsXor(APBG_INDEX, 		CBLACK);	% Aperture backgroundsetDotsXor(T_RED_INDEX, 	CRED);		% TargetssetDotsXor(T_GREEN_INDEX, 	CGREEN);setDotsXor(T_BLUE_INDEX, 	CBLUE);setDotsXor(T_YELLOW_INDEX, 	CYELLOW);setDotsXor(T_WHITE_INDEX, 	CWHITE);setDotsXor(T_GRAY_INDEX, 	CGRAY);%% SUBFUNCTION%function setDotsXor(index, color)% setDotsXor%	sets the DOTS_CLUT (color look-up table) values%	for xor'ing the given index with each dot type%	If the second argument is given, the given index%		is in the foreground, so use the color%	Otherwise the dots are in the foreground so use%		the appropriate color for eachdeclareGlobalsif nargin == 1	DOTS_CLUT(bitxor(index, DOT_RED_INDEX) 	  + 1, :)	= CRED;	DOTS_CLUT(bitxor(index, DOT_GREEN_INDEX)  + 1, :)	= CGREEN;	DOTS_CLUT(bitxor(index, DOT_BLUE_INDEX)   + 1, :)	= CBLUE;	DOTS_CLUT(bitxor(index, DOT_YELLOW_INDEX) + 1, :)	= CYELLOW;	DOTS_CLUT(bitxor(index, DOT_WHITE_INDEX)  + 1, :)	= CWHITE;	DOTS_CLUT(bitxor(index, DOT_GRAY1_INDEX)  + 1, :)	= CGRAY1;	DOTS_CLUT(bitxor(index, DOT_GRAY2_INDEX)  + 1, :)	= CGRAY2;else	DOTS_CLUT(bitxor(index, DOT_RED_INDEX) 	  + 1, :)	= color;	DOTS_CLUT(bitxor(index, DOT_GREEN_INDEX)  + 1, :)	= color;	DOTS_CLUT(bitxor(index, DOT_BLUE_INDEX)   + 1, :)	= color;	DOTS_CLUT(bitxor(index, DOT_YELLOW_INDEX) + 1, :)	= color;	DOTS_CLUT(bitxor(index, DOT_WHITE_INDEX)  + 1, :)	= color;	DOTS_CLUT(bitxor(index, DOT_GRAY1_INDEX)  + 1, :)	= color;	DOTS_CLUT(bitxor(index, DOT_GRAY2_INDEX)  + 1, :)	= color;end