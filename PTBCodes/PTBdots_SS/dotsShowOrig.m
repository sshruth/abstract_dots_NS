function dotsShow(rseed, duration, fp)% July 2014. Modif by adz to show huk noise.% % function dots8(rseed, duration)% % shows multiple patches of dots on the screen % %   rseed   random seed, can be a single value or an array. when an array%           the state of the random number generator is set to prod(rseed).%           Rex usually send a vector with two number [seed_base seed_var]%   duration    an array of durations, set the duration to -1 when a dots%               patch should not be shown %   global screen_struct dots_struct huk_struct MAX_DOTS_PER_FRAME udpmsg_struct%% function parameters show_huk = false;if dots_struct(1).coherence_std>0    %reset the random number generator    if nargin>=1 && ~isempty(rseed)        rand('twister', prod(rseed));    else        rand('state', sum(100*clock));    end    show_huk = true;    stim_id  = ceil(huk_struct.num_stims*rand());        Igamma3d = huk_struct.stimuli{stim_id};    end%REPEAT reset the random number generator, to %use the same offline dot re-generation codeif nargin>=1 && ~isempty(rseed)    rand('twister', prod(rseed));else	rand('state', sum(100*clock));end;    %set maximum dot duration to 10 sec if not specifiedif nargin<2 || isempty(duration),    duration = 10;else    duration = duration(:)';    %make sure it is a row vector end;    %if a valid file pointer is not specified print the udpmsg commands on    %the standard output if nargin<3 || isempty(fp),    fp = 1;end;    % save the command id, it will be used to send "executed" after the    % first frame of dots is shown id_ff = udpmsg_struct.recv_id;      % set the break_loop id to empty for now. will be filled when Rex sends    % the break loop commandid_bl = '';  %% Initialize dots parameters      %set variables that will be needed for the calculation of dots positionaperture = cat(1, dots_struct.aperture); % we will generate dots in a                                           % bigger aperture than                                           % necessary and                                           % then apply a mask of                                           % appropriate sizeaperture(3:4) = aperture(3:4) * 2;direction = cat(1, dots_struct.direction);density = cat(1, dots_struct.density);        %calculate the number of dots for a 'rectangular' aperture, we        %will apply an oval mask at each framendots = min(MAX_DOTS_PER_FRAME, ...            round(density .* (aperture(:,3).*aperture(:,4)) / screen_struct.mon_refresh));num_patch = length(dots_struct);loopi = ones(num_patch, 1);dxdy = cell(num_patch, 1);dot_angle = pi*direction/180;d_ppd = cell(num_patch, 1);dot_pos = cell(num_patch, 1);AP = repmat(struct([]), num_patch, 1);if length(duration)==1,    duration = repmat(duration, [num_patch,1]);end;for df = num_patch : -1 : 1,    %loop in reverse order to avoid memory reallocation        %define the ellipse apertures in the screen coordinates    AP(df).type = 'ellipse';    AP(df).spec.center = deg2screen(aperture(df,1:2), screen_struct, 'v');    AP(df).spec.radius = aperture(df,3:4)/2 * screen_struct.pix_per_deg;            %find the xy displacement of coherent dots for each dot field    dxdy{df} = repmat(dots_struct(df).speed*dots_struct(df).interval/screen_struct.mon_refresh*...                      [cos(dot_angle(df)) -sin(dot_angle(df))], ndots(df), 1) * screen_struct.pix_per_deg;        d_ppd{df} = repmat(AP(df).spec.radius, ndots(df), 1);    dot_pos{df} = (rand(ndots(df),2,dots_struct(df).interval)-0.5)*2;    for j = 1 : dots_struct(df).interval,        dot_pos{df}(:,:,j) = dot_pos{df}(:,:,j) .* d_ppd{df};    end;        %allocate memory for saving the dot position     dots_struct(df).dot_pos = nan(ndots(df), 2, ceil(screen_struct.mon_refresh*(duration(df)+1)));        %keep track of the number of frames shown    dots_struct(df).shown_frames = 0;end;    %make a copy of AP struct with aperture center set to zero (used    %for defining the maresk) AP_ = AP;for df = 1 : num_patch,    AP_(df).spec.center = [0 0];    AP_(df).spec.radius =  AP_(df).spec.radius/2; % cut down to                                                 % appropriate size                                                 % since we                                                 % generated twice                                                 % as many as neededend;%% draw dots on the screen break_loop = 0;start_t = GetSecs;  %save the start time. it will be updated after the first frame is shownwhile 1,    %enless loop        cur_t = GetSecs - start_t;             %which dots patches are still running     show_patch = find(cur_t < duration);        %check if all dot fields have finished showing. note that the code        %allows different dot fields to continue for different periods.     if isempty(show_patch),        break_loop = 1;    end;            %% MANAGE THE UDP MESSAGING         % REX sets break_loop to 1 to stop the presentation        % all other messages can be handled too, including changing the        % dots parameters or target appearance.    if udpmsg('check'),        [message, id] = udpmsg('receive');        if ~isempty(message),                %log the message in fp             fprintf(fp,'%s\n', message);            %fprintf('%s, %s\n', message, id);                            %evaluate the message            eval(message);                %confirm the execution of the message unless break_loop is                %set to one            if break_loop == 0,                udpmsg('send', 'EXECUTED', id);            else                id_bl = id;            end;        end;    end;            % break the loop if necesary     if break_loop,        break;    end;                % update the dot position and draw them on the screen    for df = show_patch,                %show huk noise if required        if (show_huk)                        Igamma = Igamma3d(:,:,dots_struct(df).shown_frames + 1);                        texturePointer(dots_struct(df).shown_frames + 1) = Screen('MakeTexture', screen_struct.cur_window, Igamma);            rotation = -1 * direction(df);%-1 to make anti-clockwise                        filtMode  = 0;            hukApRect = AP(df).spec.center([1 2 1 2]) + AP_(df).spec.radius([1 2 1 2]) .* [-1 -1 1 1];            Screen('DrawTexture', screen_struct.cur_window, ...                  texturePointer(dots_struct(df).shown_frames + 1),[],hukApRect, rotation,filtMode);        end                            %find the index of coherently moving dots in this frame        L = rand(ndots(df),1) < dots_struct(df).coherence;            %move the coherent dots        dot_pos{df}(L,:,loopi(df)) = dot_pos{df}(L,:,loopi(df)) + dxdy{df}(L,:);            %replace the other dots        dot_pos{df}(~L,:,loopi(df)) = (rand(sum(~L),2)-0.5)*2 .* d_ppd{df}(~L,:);            %wrap around        L = dot_pos{df}(:,1,loopi(df)) > d_ppd{df}(:,1);        dot_pos{df}(L,1,loopi(df)) = dot_pos{df}(L,1,loopi(df)) - 2*d_ppd{df}(L,1);        L = dot_pos{df}(:,1,loopi(df)) < -d_ppd{df}(:,1);        dot_pos{df}(L,1,loopi(df)) = 2*d_ppd{df}(L,1) - dot_pos{df}(L,1,loopi(df));        L = dot_pos{df}(:,2,loopi(df)) > d_ppd{df}(:,2);        dot_pos{df}(L,2,loopi(df)) = dot_pos{df}(L,2,loopi(df)) - 2*d_ppd{df}(L,2);        L = dot_pos{df}(:,2,loopi(df)) < -d_ppd{df}(:,2);        dot_pos{df}(L,2,loopi(df)) = 2*d_ppd{df}(L,2) - dot_pos{df}(L,2,loopi(df));                %find dots that should be shown in the aperture, note that dot_pos            %is calculated relative to the center of aperture. so use aperture_            %made for this purpose        L = isInsideRegion(dot_pos{df}(:,:,loopi(df)), AP_(df));            %round the dot_pos but save it in another place because we'd like            %dot_pos to keep track of decimals            %also rotate the matrix because Screen wants positions in row format         pos = round(dot_pos{df}(L,:,loopi(df)))';            %put dots on the screen        if any(isnan(prod(pos,1))==0),            Screen('DrawDots', screen_struct.cur_window, pos, dots_struct(df).dot_size, dots_struct(df).dot_color', AP(df).spec.center);        end;            %increment the frame counter             dots_struct(df).shown_frames = dots_struct(df).shown_frames + 1;        %save the location of the shown dots        dots_struct(df).dot_pos(L,:,dots_struct(df).shown_frames) = pos';        %update the loop counter        loopi(df) = loopi(df) + 1;        if loopi(df) > dots_struct(df).interval,            loopi(df) = 1;        end;            end;            %redraw the fixation point and targets because the flip command    %erases them on each frame!    if dots_struct(show_patch(1)).shown_frames == 1,        targDraw([], [], 0, 1); % flip PhotoDetectorFlash    else,        targDraw([], [], 0, 0); % don't flip it on every frame    end        %flip the screen     flipScreen;           %set start_t after the first frame. this is the true beginning of    %dots. also send a message at the end of the first frame. for this    %message use the id of the command that called showDots.    if dots_struct(show_patch(1)).shown_frames == 1,        start_t = GetSecs;        udpmsg('send', 'EXECUTED', id_ff);    end; end;%clear the dot field. targDraw([], [], 0, 1); % flip PhotoDetectorFlash%flip the screen flipScreen;       %send "executed". use the id of the command that set break_loop to 1if ~isempty(id_bl),        udpmsg('send', 'EXECUTED', id_bl);    %fprintf('dots duration: %f sec\n', GetSecs-start_t);    %fprintf('dot frames = %f\n', dots_struct(df).shown_frames);end;    %save the shown dot locations    %known bug: this line assumes only one patch of dots. it    %needs to be replaced by a for loop to accommodate multiple    %patchesfor df = 1 : length(dots_struct),    dots_struct(df).dot_pos = dots_struct(df).dot_pos(:,:,1:dots_struct(df).shown_frames);end;%dots_struct(1).dot_pos% close huk texturesif (show_huk)    Screen('Close', texturePointer);end