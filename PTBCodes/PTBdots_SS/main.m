% This is the routine that manages rex calls, execute it first.% To stop the program either send runPTB=0 from Rex or press  Apple+Esc.% clear all;declareGlobals;setGlobalDefaults;% focus on command window%commandwindow;% set the path for the current experimentinitPath();% use unified key names for compatibility across platformsKbName('UnifyKeyNames');% initialize globalsdefineGlobals;% open udp communication lineudpmsg('open', localIP, rexIP, port);% wait for all keys to be released% also call WaitSecs to have the mex file loaded, see PTB helpwhile KbCheck,    WaitSecs(0.1);end;% START THE EXPERIMENT% use try ... catch ... to ensure that the screen will not freeze in case% of an error in the codetry    fp = fopen('rexout','w');        %initialize the screen    initScreen([],[],[],[],[]);        %print the setting to ensure the screen is set correctly    printScreen(screen_struct);        %set the priority to the maximum    Priority(MaxPriority(screen_struct.cur_screen));        %loop through Rex commands    runPTB = 1;        %number of unknown commands received    unknown = 0;        t_udpsend_clock = GetSecs;        Screen('Flip',CUR_WINDOW);            %loop until "runPTB" is set to 0    while runPTB,        %check for a Rex message        if udpmsg('check'),            [message, id] = udpmsg('receive');            if ~isempty(message),                                disp([message,' received']);                %log the message in "rexout" file                fprintf(fp,'%s\n', message);                % fprintf('%s, %s\n', message, id);                %evaluate it, counting the unknown commands                eval(message, 'unknown = unknown + 1');                %confirm the execution of the message                %limited sending executed to postpone Rex's cpu overload                                fs=@(x)~isempty(strfind(message,x));                if ~any(cellfun(fs,{'dotsShow'})),                    udpmsg('send', 'EXECUTED', id);                end                            end;        end;                %abort if runPTB is set to 0        if runPTB == 0,            fprintf('\n\nSession ended by Rex\n\n');            break;        end;                %check for the abort key        [keyIsDown, secs, keyCode] = KbCheck;        if keyIsDown && all(keyCode(abort_key)),            break;        end;                % don't go too fast        WaitSecs(1e-3);    end;        %set the priority of the thread back to zero    Priority(0);        %close all the windows and screens    Screen('CloseAll');        %move the cursor to the middle of screen 0    [a,b] = RectCenter(Screen(0,'Rect'));    WaitSetMouse(a, b, 0);    ShowCursor;        %close the log file    fclose(fp);        %show how many unknown commands were encountered    if unknown > 0,        fprintf('\n\n ***********************\n');        fprintf('%d unknown commands received from Rex\n', unknown);        fprintf(' ***********************\n\n');    end;    catch    fprintf('\n\nStopped due to ERROR\n\n');        %set the priority of the thread back to zero    Priority(0);        %close the screen and show the cursor    Screen('CloseAll');    ShowCursor;        %close the log file    fclose(fp);        %rethrow the error to declare the error that stopped the program    %note that this should be the last line of the code. Functions    %following this line weill not be executed. Hey! It is generating    %an error!    err = lasterror;    for i = 1 : length(err.stack),        fprintf('error in line %d of %s\n', err.stack(i).line, err.stack(i).name);    end;    rethrow(err);end;Screen('CloseAll');fprintf('\n\n **************************************** \n\n');