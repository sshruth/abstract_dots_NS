function initScreen(num_targets, num_dots_patch, mon_width_cm, view_dist_cm, went_flag)% function initScreen(num_targets, num_dots_patch, mon_horizontal_cm, view_dist_cm)% initializes the screen % % 1. OPEN THE SCREEN% 2. COMPUTE PIXELS PER DEGREE% 3. MONITOR'S FRAME RATE% 4. HIDE THE CURSOR  % 5. ALLOCATE MEMORY FOR TARGETS AND DOTS PATCH STRUCTS % % Input:%   screen_struct% % Output%   screen_struct% % % 09/26/07  RK modified ShadlenDots initScreen.m% global screen_struct dots_struct target_struct huk_structdeclareGlobals;    % 1. SEED RANDOM NUMBER GENERATORrand('state',sum(100*clock));    % 2. OPEN THE SCREEN.makeCLUT; % Added on 03/23/09 to use 256 colors in the rig3.	% Use the main screen (the one with the menu bar)CUR_SCREEN = 1;	% Set the background to the aperture bg value.[screen_struct.cur_window, screen_struct.screen_rect] = Screen(screen_struct.cur_screen, 'OpenWindow', screen_struct.screen_bkg);screen_struct.screen_rectCUR_WINDOW  = screen_struct.cur_window;SCREEN_RECT = screen_struct.screen_rect;CENTER_X    = SCREEN_RECT(3)/2;CENTER_Y    = SCREEN_RECT(4)/2;if CUR_SCREEN == 0    Screen('CloseAll');end    % 3. COMPUTE PIXELS PER DEGREE for the given screen    % use the horizontal dimension of the actual view screen and the viewing    % distance... these used to be globals but are now local to this routine    % so that they can (optionally) be passed as arguments from REXif nargin < 3 || isempty(mon_width_cm)	mon_width_cm  	= 32;	% horizontal dimension (cm) of SCREEN_RECT    screen_struct.mon_width_cm = mon_width_cm;endif nargin < 4 || isempty(view_dist_cm)	view_dist_cm 		= 48;	% IMPORTANT to set this (cm) VIEW DISTANCE    screen_struct.view_dist_cm = view_dist_cm;end            % (pix/screen) * ... (screen/rad) * ... rad/degPIX_PER_DEG = SCREEN_RECT(3) * ...    (1 ./ (2 * atan2(mon_width_cm / 2, view_dist_cm))) * ...	pi/180;screen_struct.pix_per_deg = PIX_PER_DEG;FP_SIZE_PIX     = FP_SIZE_DEG * PIX_PER_DEG;GRID_SIZE_PIX   = GRID_SIZE_DEG * PIX_PER_DEG;STIM_SIZE_PIX   = STIM_SIZE_DEG * PIX_PER_DEG;LENGTH          = STIM_SIZE_PIX *4;TARGET_SIZE_PIX = TARGET_SIZE_DEG * PIX_PER_DEG;                        screen_structScreen('Preference', 'SkipSyncTests', 1);% 4. Hide the cursor% put the cursor at the center of screen[a,b] = RectCenter(screen_struct.screen_rect);WaitSetMouse(a, b, screen_struct.cur_screen);HideCursor;% a few more details...if nargin < 4 || isempty(went_flag)	WENT_FLAG = 0;else	WENT_FLAG = went_flag;end% 5. allocate memory for targets and dots patchesif nargin<2 || isempty(num_dots_patch),    num_dots_patch = 1;end;dots_struct = repmat(dots_struct(1), num_dots_patch, 1);if nargin<1 || isempty(num_targets),    num_targets = 1;end;target_struct(1).show = 0;target_struct = repmat(target_struct(1), num_targets, 1);