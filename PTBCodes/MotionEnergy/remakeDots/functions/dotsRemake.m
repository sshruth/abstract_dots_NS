function [dotpos,v_coh_frame] = dotsRemake(rseed,duration,dots_struct,screen_struct,MAX_DOTS_PER_FRAME,...    screen_width_cm,distance_to_screen_cm)%% function dots8(rseed, duration)%% shows multiple patches of dots on the screen%%   rseed   random seed, can be a single value or an array. when an array%           the state of the random number generator is set to prod(rseed).%           Rex usually send a vector with two number [seed_base seed_var]%   duration    an array of durations, set the duration to -1 when a dots%               patch should not be shown%resolution_w = screen_struct.screen_rect(3);pixPerDeg = pi * resolution_w / ...    atan(screen_width_cm/distance_to_screen_cm/2) / 360;screen_struct.pix_per_deg = pixPerDeg;% global screen_struct dots_struct MAX_DOTS_PER_FRAME udpmsg_struct TR_NUMdf = 1;%% function parametersrand('twister', prod(rseed));randn('state', prod(rseed)+1); %adz%set maximum dot duration to 10 sec if not specifiedif nargin<2 || isempty(duration),    duration = 10;else    duration = duration(:)';    %make sure it is a row vectorend%% Initialize dots parameters%set variables that will be needed for the calculation of dots positionaperture = cat(1, dots_struct.aperture); % we will generate dots in a% bigger aperture than% necessary and% then apply a mask of% appropriate sizeaperture(3:4) = aperture(3:4) * 2;direction   = cat(1, dots_struct.direction);density     = cat(1, dots_struct.density);%calculate the number of dots for a 'rectangular' aperture, we%will apply an oval mask at each framendots       = min(MAX_DOTS_PER_FRAME, ...    round(density .* (aperture(:,3).*aperture(:,4)) / screen_struct.mon_refresh));num_patch   = length(dots_struct);loopi       = ones(num_patch, 1);dxdy        = cell(num_patch, 1);dot_angle   = pi*direction/180;d_ppd       = cell(num_patch, 1);dot_pos     = cell(num_patch, 1);AP = repmat(struct([]), num_patch, 1);if length(duration)==1    duration = repmat(duration, [num_patch,1]);endfor df = num_patch : -1 : 1    %loop in reverse order to avoid memory reallocation    %define the ellipse apertures in the screen coordinates    AP(df).type = 'ellipse';    AP(df).spec.center = deg2screen(aperture(df,1:2), screen_struct, 'v');    AP(df).spec.radius = aperture(df,3:4)/2 * screen_struct.pix_per_deg;        %find the xy displacement of coherent dots for each dot field    dxdy{df} = repmat(dots_struct(df).speed*dots_struct(df).interval/screen_struct.mon_refresh*...        [cos(dot_angle(df)) -sin(dot_angle(df))], ndots(df), 1) * screen_struct.pix_per_deg;        d_ppd{df}   = repmat(AP(df).spec.radius, ndots(df), 1);    dot_pos{df} = (rand(ndots(df),2,dots_struct(df).interval)-0.5)*2;    for j = 1 : dots_struct(df).interval        dot_pos{df}(:,:,j) = dot_pos{df}(:,:,j) .* d_ppd{df};    end    %allocate memory for saving the dot position    dots_struct(df).dot_pos = nan(ndots(df), 2, ceil(screen_struct.mon_refresh*(duration(df)+1)));    %keep track of the number of frames shown    dots_struct(df).shown_frames = 0;end;%make a copy of AP struct with aperture center set to zero (used%for defining the maresk)AP_ = AP;for df = 1 : num_patch,    AP_(df).spec.center = [0 0];    AP_(df).spec.radius =  AP_(df).spec.radius/2; % cut down to    % appropriate size    % since we    % generated twice    % as many as neededend;%% draw dots on the screennframes = ceil(duration*screen_struct.mon_refresh);dotpos = cell(nframes,1);v_coh_frame = nan(nframes,1);for iframes=1:nframes        %% MANAGE THE UDP MESSAGING        % update the dot position and draw them on the screen    %     for df = show_patch        %find the index of coherently moving dots in this frame    coh_frame = dots_struct(df).coherence + randn * dots_struct(df).coherence_std; %adz    L = rand(ndots(df),1) < abs(coh_frame);        %move the coherent dots    %         dot_pos{df}(L,:,loopi(df)) = dot_pos{df}(L,:,loopi(df)) + dxdy{df}(L,:);    if coh_frame>0        dot_pos{df}(L,:,loopi(df)) = dot_pos{df}(L,:,loopi(df)) + dxdy{df}(L,:); %adz    else %make motion in the opposite direction        dot_pos{df}(L,:,loopi(df)) = dot_pos{df}(L,:,loopi(df)) - dxdy{df}(L,:); %adz    end        %replace the other dots    dot_pos{df}(~L,:,loopi(df)) = (rand(sum(~L),2)-0.5)*2 .* d_ppd{df}(~L,:);        %wrap around    L = dot_pos{df}(:,1,loopi(df)) > d_ppd{df}(:,1);    dot_pos{df}(L,1,loopi(df)) = dot_pos{df}(L,1,loopi(df)) - 2*d_ppd{df}(L,1);    L = dot_pos{df}(:,1,loopi(df)) < -d_ppd{df}(:,1);    dot_pos{df}(L,1,loopi(df)) = 2*d_ppd{df}(L,1) - dot_pos{df}(L,1,loopi(df));    L = dot_pos{df}(:,2,loopi(df)) > d_ppd{df}(:,2);    dot_pos{df}(L,2,loopi(df)) = dot_pos{df}(L,2,loopi(df)) - 2*d_ppd{df}(L,2);    L = dot_pos{df}(:,2,loopi(df)) < -d_ppd{df}(:,2);    dot_pos{df}(L,2,loopi(df)) = 2*d_ppd{df}(L,2) - dot_pos{df}(L,2,loopi(df));            %find dots that should be shown in the aperture, note that dot_pos    %is calculated relative to the center of aperture. so use aperture_    %made for this purpose    L = isInsideRegion(dot_pos{df}(:,:,loopi(df)), AP_(df));    %round the dot_pos but save it in another place because we'd like    %dot_pos to keep track of decimals    %also rotate the matrix because Screen wants positions in row format    pos = round(dot_pos{df}(L,:,loopi(df)))';    %put dots on the screen        %increment the frame counter    dots_struct(df).shown_frames = dots_struct(df).shown_frames + 1;    %save the location of the shown dots    dots_struct(df).dot_pos(L,:,dots_struct(df).shown_frames) = pos';    %update the loop counter    loopi(df) = loopi(df) + 1;    if loopi(df) > dots_struct(df).interval        loopi(df) = 1;    end        dotpos{iframes} = pos;    v_coh_frame(iframes) = coh_frame;    end% %save the shown dot locations% for df = 1 : length(dots_struct),%     dots_struct(df).dot_pos = dots_struct(df).dot_pos(:,:,1:dots_struct(df).shown_frames);%     dots_xyt{df} = dots_struct(df).dot_pos;% end